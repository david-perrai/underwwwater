/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * Underwwwater API
 * The underwwwater API description
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import {
  computed,
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

import type {
  CreateDiveDto,
  Dive,
  DivesControllerFindAllParams,
  UpdateDiveDto
} from '.././model';

import { authFetch } from '../../fetch-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Create a new dive
 */
export type divesControllerCreateResponse201 = {
  data: Dive
  status: 201
}

export type divesControllerCreateResponse400 = {
  data: void
  status: 400
}

export type divesControllerCreateResponseSuccess = (divesControllerCreateResponse201) & {
  headers: Headers;
};
export type divesControllerCreateResponseError = (divesControllerCreateResponse400) & {
  headers: Headers;
};

export type divesControllerCreateResponse = (divesControllerCreateResponseSuccess | divesControllerCreateResponseError)

export const getDivesControllerCreateUrl = () => {




  return `/dives`
}

export const divesControllerCreate = async (createDiveDto: CreateDiveDto, options?: RequestInit): Promise<divesControllerCreateResponse> => {

  return authFetch<divesControllerCreateResponse>(getDivesControllerCreateUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(
        createDiveDto,)
    }
  );
}




export const getDivesControllerCreateMutationOptions = <TError = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof divesControllerCreate>>, TError, { data: CreateDiveDto }, TContext>, request?: SecondParameter<typeof authFetch> }
  ): UseMutationOptions<Awaited<ReturnType<typeof divesControllerCreate>>, TError, { data: CreateDiveDto }, TContext> => {

  const mutationKey = ['divesControllerCreate'];
  const { mutation: mutationOptions, request: requestOptions } = options ?
    options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey, }, request: undefined };




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof divesControllerCreate>>, { data: CreateDiveDto }> = (props) => {
    const { data } = props ?? {};

    return divesControllerCreate(data, requestOptions)
  }






  return { mutationFn, ...mutationOptions }
}

export type DivesControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof divesControllerCreate>>>
export type DivesControllerCreateMutationBody = CreateDiveDto
export type DivesControllerCreateMutationError = void

/**
* @summary Create a new dive
*/
export const useDivesControllerCreate = <TError = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof divesControllerCreate>>, TError, { data: CreateDiveDto }, TContext>, request?: SecondParameter<typeof authFetch> }
    , queryClient?: QueryClient): UseMutationReturnType<
      Awaited<ReturnType<typeof divesControllerCreate>>,
      TError,
      { data: CreateDiveDto },
      TContext
    > => {
  return useMutation(getDivesControllerCreateMutationOptions(options), queryClient);
}
/**
* @summary Get all dives
*/
export type divesControllerFindAllResponse200 = {
  data: Dive[]
  status: 200
}

export type divesControllerFindAllResponseSuccess = (divesControllerFindAllResponse200) & {
  headers: Headers;
};
;

export type divesControllerFindAllResponse = (divesControllerFindAllResponseSuccess)

export const getDivesControllerFindAllUrl = (params?: DivesControllerFindAllParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {

    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/dives?${stringifiedParams}` : `/dives`
}

export const divesControllerFindAll = async (params?: DivesControllerFindAllParams, options?: RequestInit): Promise<divesControllerFindAllResponse> => {

  return authFetch<divesControllerFindAllResponse>(getDivesControllerFindAllUrl(params),
    {
      ...options,
      method: 'GET'


    }
  );
}





export const getDivesControllerFindAllQueryKey = (params?: MaybeRef<DivesControllerFindAllParams>,) => {
  return [
    'dives', ...(params ? [params] : [])
  ] as const;
}


export const getDivesControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof divesControllerFindAll>>, TError = unknown>(params?: MaybeRef<DivesControllerFindAllParams>, options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof divesControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof authFetch> }
) => {

  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = getDivesControllerFindAllQueryKey(params);



  const queryFn: QueryFunction<Awaited<ReturnType<typeof divesControllerFindAll>>> = ({ signal }) => divesControllerFindAll(unref(params), { signal, ...requestOptions });





  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof divesControllerFindAll>>, TError, TData>
}

export type DivesControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof divesControllerFindAll>>>
export type DivesControllerFindAllQueryError = unknown


/**
 * @summary Get all dives
 */

export function useDivesControllerFindAll<TData = Awaited<ReturnType<typeof divesControllerFindAll>>, TError = unknown>(
  params?: MaybeRef<DivesControllerFindAllParams>, options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof divesControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof authFetch> }
  , queryClient?: QueryClient
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDivesControllerFindAllQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




/**
 * @summary Get a dive by ID
 */
export type divesControllerFindOneResponse200 = {
  data: Dive
  status: 200
}

export type divesControllerFindOneResponse404 = {
  data: void
  status: 404
}

export type divesControllerFindOneResponseSuccess = (divesControllerFindOneResponse200) & {
  headers: Headers;
};
export type divesControllerFindOneResponseError = (divesControllerFindOneResponse404) & {
  headers: Headers;
};

export type divesControllerFindOneResponse = (divesControllerFindOneResponseSuccess | divesControllerFindOneResponseError)

export const getDivesControllerFindOneUrl = (id: number,) => {




  return `/dives/${id}`
}

export const divesControllerFindOne = async (id: number, options?: RequestInit): Promise<divesControllerFindOneResponse> => {

  return authFetch<divesControllerFindOneResponse>(getDivesControllerFindOneUrl(id),
    {
      ...options,
      method: 'GET'


    }
  );
}





export const getDivesControllerFindOneQueryKey = (id: MaybeRef<number>,) => {
  return [
    'dives', id
  ] as const;
}


export const getDivesControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof divesControllerFindOne>>, TError = void>(id: MaybeRef<number>, options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof divesControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof authFetch> }
) => {

  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = getDivesControllerFindOneQueryKey(id);



  const queryFn: QueryFunction<Awaited<ReturnType<typeof divesControllerFindOne>>> = ({ signal }) => divesControllerFindOne(unref(id), { signal, ...requestOptions });





  return { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof divesControllerFindOne>>, TError, TData>
}

export type DivesControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof divesControllerFindOne>>>
export type DivesControllerFindOneQueryError = void


/**
 * @summary Get a dive by ID
 */

export function useDivesControllerFindOne<TData = Awaited<ReturnType<typeof divesControllerFindOne>>, TError = void>(
  id: MaybeRef<number>, options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof divesControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof authFetch> }
  , queryClient?: QueryClient
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDivesControllerFindOneQueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




/**
 * @summary Update a dive
 */
export type divesControllerUpdateResponse200 = {
  data: Dive
  status: 200
}

export type divesControllerUpdateResponse404 = {
  data: void
  status: 404
}

export type divesControllerUpdateResponseSuccess = (divesControllerUpdateResponse200) & {
  headers: Headers;
};
export type divesControllerUpdateResponseError = (divesControllerUpdateResponse404) & {
  headers: Headers;
};

export type divesControllerUpdateResponse = (divesControllerUpdateResponseSuccess | divesControllerUpdateResponseError)

export const getDivesControllerUpdateUrl = (id: number,) => {




  return `/dives/${id}`
}

export const divesControllerUpdate = async (id: number,
  updateDiveDto: UpdateDiveDto, options?: RequestInit): Promise<divesControllerUpdateResponse> => {

  return authFetch<divesControllerUpdateResponse>(getDivesControllerUpdateUrl(id),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(
        updateDiveDto,)
    }
  );
}




export const getDivesControllerUpdateMutationOptions = <TError = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof divesControllerUpdate>>, TError, { id: number; data: UpdateDiveDto }, TContext>, request?: SecondParameter<typeof authFetch> }
  ): UseMutationOptions<Awaited<ReturnType<typeof divesControllerUpdate>>, TError, { id: number; data: UpdateDiveDto }, TContext> => {

  const mutationKey = ['divesControllerUpdate'];
  const { mutation: mutationOptions, request: requestOptions } = options ?
    options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey, }, request: undefined };




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof divesControllerUpdate>>, { id: number; data: UpdateDiveDto }> = (props) => {
    const { id, data } = props ?? {};

    return divesControllerUpdate(id, data, requestOptions)
  }






  return { mutationFn, ...mutationOptions }
}

export type DivesControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof divesControllerUpdate>>>
export type DivesControllerUpdateMutationBody = UpdateDiveDto
export type DivesControllerUpdateMutationError = void

/**
* @summary Update a dive
*/
export const useDivesControllerUpdate = <TError = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof divesControllerUpdate>>, TError, { id: number; data: UpdateDiveDto }, TContext>, request?: SecondParameter<typeof authFetch> }
    , queryClient?: QueryClient): UseMutationReturnType<
      Awaited<ReturnType<typeof divesControllerUpdate>>,
      TError,
      { id: number; data: UpdateDiveDto },
      TContext
    > => {
  return useMutation(getDivesControllerUpdateMutationOptions(options), queryClient);
}
/**
* @summary Delete a dive
*/
export type divesControllerRemoveResponse200 = {
  data: void
  status: 200
}

export type divesControllerRemoveResponse404 = {
  data: void
  status: 404
}

export type divesControllerRemoveResponseSuccess = (divesControllerRemoveResponse200) & {
  headers: Headers;
};
export type divesControllerRemoveResponseError = (divesControllerRemoveResponse404) & {
  headers: Headers;
};

export type divesControllerRemoveResponse = (divesControllerRemoveResponseSuccess | divesControllerRemoveResponseError)

export const getDivesControllerRemoveUrl = (id: number,) => {




  return `/dives/${id}`
}

export const divesControllerRemove = async (id: number, options?: RequestInit): Promise<divesControllerRemoveResponse> => {

  return authFetch<divesControllerRemoveResponse>(getDivesControllerRemoveUrl(id),
    {
      ...options,
      method: 'DELETE'


    }
  );
}




export const getDivesControllerRemoveMutationOptions = <TError = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof divesControllerRemove>>, TError, { id: number }, TContext>, request?: SecondParameter<typeof authFetch> }
  ): UseMutationOptions<Awaited<ReturnType<typeof divesControllerRemove>>, TError, { id: number }, TContext> => {

  const mutationKey = ['divesControllerRemove'];
  const { mutation: mutationOptions, request: requestOptions } = options ?
    options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey, }, request: undefined };




  const mutationFn: MutationFunction<Awaited<ReturnType<typeof divesControllerRemove>>, { id: number }> = (props) => {
    const { id } = props ?? {};

    return divesControllerRemove(id, requestOptions)
  }






  return { mutationFn, ...mutationOptions }
}

export type DivesControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof divesControllerRemove>>>

export type DivesControllerRemoveMutationError = void

/**
* @summary Delete a dive
*/
export const useDivesControllerRemove = <TError = void,
  TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof divesControllerRemove>>, TError, { id: number }, TContext>, request?: SecondParameter<typeof authFetch> }
    , queryClient?: QueryClient): UseMutationReturnType<
      Awaited<ReturnType<typeof divesControllerRemove>>,
      TError,
      { id: number },
      TContext
    > => {
  return useMutation(getDivesControllerRemoveMutationOptions(options), queryClient);
}
